var test = require('tape');
var ndarray = require('ndarray');
var helpers = require('../lib/helpers');
var equals = require('ndarray-equals');
var array_equals = require('array-equal');
var cartesian = require('../');

var are_indices_terminal = helpers.are_indices_terminal;
var check_index = helpers.check_index;
var conditionally_increment = helpers.conditionally_increment;

var increment_indices = helpers.increment_indices;
var allocate_ndarray = helpers.allocate_ndarray;
var all_same_type = helpers.all_same_type;
var copy_data_tuple = helpers.copy_data_tuple;
var write_cartesian_product = helpers.write_cartesian_product;

test('are_indices_terminal', function(t){
  var a1 = ndarray(new Float32Array([0, 1]));
  var a2 = ndarray(new Float32Array([0, 1]));
  var args = [a1, a2];
  var indices = [1, 1];
  t.assert(are_indices_terminal(indices, args));

  indices = [1, 0];
  t.assert(!are_indices_terminal(indices, args));
  t.end();
});

test('check_index', function(t){
  var a = ndarray(new Float32Array([1, 2, 3]));
  t.assert(check_index(1, a));
  t.assert(!check_index(2, a));
  t.end();
});

test('conditionally_increment', function(t){
  var a1 = ndarray([1,2]);
  var a2 = ndarray([1,2,3,4]);
  var a3 = ndarray([4]);
  var indices = [1, 0, 0];
  var i = 0;
  t.assert(!conditionally_increment(indices, [a1, a2, a3], i));
  t.assert(array_equals(indices, [0, 0, 0]));
  t.assert(conditionally_increment(indices, [a1, a2, a3], 1));
  t.assert(array_equals(indices, [0, 1, 0]));
  t.end();
});

test('increment_indices', function(t){
  var a1 = ndarray([1,2]);
  var a2 = ndarray([1,2,3,4]);
  var a3 = ndarray([4,5]);
  var indices = [1, 3, 0];
  increment_indices(indices, [a1, a2, a3]);
  t.assert(array_equals(indices, [0, 0, 1]));
  increment_indices(indices, [a1, a2, a3]);
  t.assert(array_equals(indices, [1, 0, 1]));
  t.end(); 
  
});

test('all_same_type', function(t){
  var a1 = ndarray([1,2]);
  var a2 = ndarray([1,2,3]);
  t.assert(all_same_type([a1, a2]));
  a2 = ndarray(new Float32Array([1,2]));
  t.assert(!all_same_type([a1, a2]));
  t.end();
});

test('allocate_ndarray', function(t){
  var a1 = ndarray(new Float32Array([1, 2]));
  var a2 = ndarray(new Float32Array([1, 2]));
  var arr = allocate_ndarray([a1, a2]);
  t.assert(equals(arr, ndarray(new Float32Array(8), [4, 2])));
  var a3 = ndarray(new Float32Array([1]));
  arr = allocate_ndarray([a1, a2, a3]);
  t.assert(equals(arr, ndarray(new Float32Array(12), [4, 3])));
  t.end();
});

test('copy_data_tuple', function(t){
  var a = ndarray(new Float32Array(8), [4, 2]);
  var a1 = ndarray(new Float32Array([1, 2]));
  var a2 = ndarray(new Float32Array([3, 4]));
  var indices = [0, 1];
  copy_data_tuple(indices, 2, [a1, a2], a);
  t.assert(equals(a, ndarray(new Float32Array([0,0,0,0,1,4,0,0]), [4, 2])));
  t.end();
});

test('write_cartesian_product', function(t){
  var a = ndarray(new Array(8), [4, 2]);
  var a1 = ndarray([1, 2]);
  var a2 = ndarray([3, 4]);
  write_cartesian_product(a, [a1, a2]);

  t.assert(equals(a, ndarray([1,3,2,3,1,4,2,4], [4, 2])));

  a = ndarray(new Float32Array(8), [4, 2]);
  a1 = ndarray(new Float32Array([1, 2]));
  a2 = ndarray(new Float32Array([3, 4]));
  write_cartesian_product(a, [a1, a2]);


  t.assert(equals(a, ndarray(new Float32Array([1,3,2,3,1,4,2,4]), [4, 2])));

  var a3 = ndarray(new Float32Array([1]));
  a = ndarray(new Float32Array(12), [4, 3]);
  write_cartesian_product(a, [a1, a2, a3]);
  t.assert(equals(a, ndarray(new Float32Array([1,3,1,2,3,1,1,4,1,2,4,1]), [4, 3])));
  t.end();
});

test('cartesian_product', function(t){
  var a1 = ndarray(new Float32Array([0, 1]));
  var a2 = ndarray(new Float32Array([0, 1]));
  var ct = cartesian(a1, a2);

  var goal = ndarray(new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), [4, 2]);
  t.assert(equals(ct, goal));

  ct = cartesian([a1, a2]);
  t.assert(equals(ct, goal));
  ct = cartesian(a1);
  t.assert(equals(ct, a1));
  t.end();
});
